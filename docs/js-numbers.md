---
title: JS Numbers
date: 2016-01-06 14:37:02
---

`Number` is one of JavaScript's primitive types

## Basics

* currently there are 7 primitive types: `Boolean`, `String`, `Number`, `Null`, `Undefined`, `Symbol` and `BigInt`
    * this is different to the possible results of the `typeof` operator
        * which are `"boolean"`, `"string"`, `"number"`, `"object"`, `"undefined"`,`"symbol"`, `"bigint"` and `"function"`
        * `typeof document.all` evaluates to `"undefined"` is a **willful violation**
        * see [typeof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof)
* by **primitive** we mean **not object**
    * this also implies that values of primitive types **has no methods**, although `"abc".length"` is valid, there's an implicit primitive wrapper object there
    * see [Primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)
* by **type** we mean **set of values**, so that the `Undefined` type is a set of only one element (singleton) `{ undefiend }`, the `Boolean` type is a set of two elements: `{ true, false }` and the `String` type is an infinite set (and accidentally a monoid)
    

According to [ECMA-262][ecma-262]:

> The Number type has exactly 18437736874454810627 (that is, 2<sup>64</sup> - 2<sup>53</sup> + 3) values, representing the double-precision 64-bit format IEEE 754-2008 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9007199254740990 (that is, 2<sup>53</sup> - 2) distinct “Not-a-Number” values of the IEEE Standard are represented in ECMAScript as a single special NaN value. 

they are distinguished into:

* infinite numbers: **positive Infinity** (+∞) and **negative Infinity** (-∞), generated by `+Infinity` (or simply `Infinity`) and `-Infinity`

* finite numbers:

    * finite zero numbers **positive zero** and **negative zero**, generated by `+0` (or simply `0`) and `-0`

    * finite non-zero values:
        * **normalized**
            * 18428729675200069632 values (that is, 2<sup>64</sup> - 2<sup>54</sup>)
            * having the form **s × m × 2<sup>e</sup>** where:
                * s(ign) is +1 or -1
                * m(antissa, significand, fraction) is a positive integer less than 2<sup>53</sup> but not less than 2<sup>52</sup>, with an implict leading 1.
                * e(xponent) is an integer ranging from -1074 to 971, inclusive with a bias of 1023
            * so `Number.MAX_SAFE_INTEGER` is 2<sup>53</sup> - 1, and `Math.pow(2, 53) === Math.pow(2, 53) + 1` => `true`
                * `Number.MAX_SAFE_INTEGER` is the largest integer *n* such that *n* and *n + 1* are both **exactly representable** as a Number value.
            * `Number.MAX_VALUE` is the largest positive finite value of the Number type (2<sup>1024</sup> - 2<sup>971</sup>)
                * to add a value X to push `Number.MAX_VALUE` to `Infinity`, according to the *"round to nearest, ties to even"* rule, then X should at least be `(2<sup>1024</sup> - (2<sup>1024</sup> - 2<sup>971</sup>)) / 2 = 2<sup>970</sup>`
                * `2 ** 970` => `9.9792015476736e+291`
                * `Number.MAX_VALUE + 9.9792015476736e+291` => `Infinity`
                * `Number.MAX_VALUE + 9.9792015476735e+291` => `1.7976931348623157e+308` (Number.MAX_VALUE)

        * **denormalized**
            * 9007199254740990 values (that is, 2<sup>53</sup> - 2)
            * having the form **s × m × 2<sup>e</sup>**
                * s is +1 or -1
                * m is a positive integer less than 2<sup>52</sup>
                * e is -1074.
            * so `Number.MIN_VALUE` is 2<sup>-1074</sup>, and `Math.pow(2, -1074) > 0 && Math.pow(2, -1075) === 0` => `true`
                * `Number.MIN_VALUE` is the smallest positive (representable) value in JS

### Note:

* all the positive and negative **integers** whose magnitude is no greater than 2<sup>53</sup> are representable in the Number type
* 2<sup>1024</sup> (which is +1 × 2<sup>53</sup> × 2<sup>971</sup>) and -2<sup>1024</sup> (which is -1 × 2<sup>53</sup> × 2<sup>971</sup>) are not representable in the `Number` type
* a finite number has an **odd significand** if it is nonzero and the integer **m** used to express it (in one of the two forms shown above) is odd. Otherwise, it has an **even significand**.
    * this is used to choose the **Number value for x** where **x** represents an exact real mathematical quantity (which might even be an irrational number such as π)
    * according to IEEE 754-2008 this procedure is called ***round to nearest, ties to even***

* see [How numbers are encoded in JavaScript](https://2ality.com/2012/04/number-encoding.html)
* see [IEEE Standard 754 Floating Point Numbers](http://steve.hollasch.net/cgindex/coding/ieeefloat.html)
* see [What Every Computer Scientist Should Know About Floating-Point Arithmetic](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)
* see [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)

## Get the Bits

According to [ECMA-262][ecma-262]:

> The bit pattern that might be observed in an ArrayBuffer or a SharedArrayBuffer after a Number value has been stored into it is not necessarily the same as the internal representation of that Number value used by the ECMAScript implementation.

but it still worth a try:

```
let toBitsStr = n => {
    let buffer = new ArrayBuffer(64)
    let num = new Float64Array(buffer, 0, 1)
    let bytes = new Uint8Array(buffer, 0, 8)
    num[0] = n
    return [].map.call(bytes, b => b.toString(2).padStart(8, '0')).reverse().join('_')
}
```

now we can inspect the bit pattern of any `Number` value:

### case **1**

` toBitsStr(1) ` => 
`00111111_11110000_00000000_00000000_00000000_00000000_00000000_00000000`

where
* s = 1
* e = 0
* m = 1.0

### case **0.1**
 
` toBitsStr(0.1) ` => 
`"00111111_10111001_10011001_10011001_10011001_10011001_10011001_10011010"`

where
* s = 1
* e = -4
* m = 1.6 (`(1.6).toString(2)` ==> `1.1001_10011001_10011001_10011001_10011001_10011001_10011010`)

### case **5e-324** (Number.MIN_VALUE)

`toBitStr(Number.MIN_VALUE)` =>
`"00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001"`

where
* s = 1
* e = -1022
* m = 2<sup>-52</sup>


[ecma-262]: http://www.ecma-international.org/publications/standards/Ecma-262.htm
